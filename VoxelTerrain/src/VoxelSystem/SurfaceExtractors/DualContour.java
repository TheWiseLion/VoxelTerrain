package VoxelSystem.SurfaceExtractors;


import java.util.ArrayList;
import java.util.List;

import VoxelSystem.VoxelSystemTables;
import VoxelSystem.VoxelData.VoxelGrid;
import VoxelSystem.VoxelSystemTables.AXIS;
import VoxelSystem.MeshBuilding.SurfacePoint;

import com.jme3.bounding.BoundingBox;
import com.jme3.math.Vector3f;

/***
 * 
 * 
 */
public class DualContour implements SurfaceExtractor{
	
	
	@Override
	public List<SurfacePoint> extractSurface(VoxelGrid hg) {
		
		Vector3f p =hg.getCorner();
		float scale = hg.getVoxelSize();
		
		//Bounding Box to limit the vertex position generated by
		//our QEF equivalent
		BoundingBox bb = new BoundingBox();
		bb.setXExtent(scale);
		bb.setYExtent(scale);
		bb.setZExtent(scale);
		
		//Error Threshold
		float threshold = (float) (Math.sqrt(3)*scale / 1000.0);
		
		Vector3f [][][] xzCache0 = new Vector3f[2][hg.getWidth()+2][hg.getDepth()+2];
		int [] lm = new int[8];
		Vector3f [] cP = new Vector3f[]{
			new Vector3f(),new Vector3f(),new Vector3f(),new Vector3f(),
			new Vector3f(),new Vector3f(),new Vector3f(),new Vector3f()
		};
		
		
		List<Vector3f> edges = new ArrayList<Vector3f>();
		List<Vector3f> normals = new ArrayList<Vector3f>();
		
		//TODO: not this:
		List<SurfacePoint> triangles = new ArrayList<SurfacePoint>(); 
		
		
		List<Vector3f> vertexList = new ArrayList<Vector3f>();
		List<Integer> triangleList = new ArrayList<Integer>();
		
		//Compute initial cache
		for(int z = -1; z < hg.getDepth(); z++){
			for(int x = -1; x < hg.getWidth(); x++){
				setCubeEdges(x,-1,z,cP,scale,p);
				int cI = getCubeInfo(cP,hg,x,-1,z,edges,normals, lm);
				//TODO: Triangle indexing
				xzCache0[0][x+1][z+1] = getIsoPoint(cI,cP,edges,normals,bb,threshold);
			}
		}
		
		for(int y=0; y < hg.getHeight(); y++){
			//Set y values:
			cP[0].y = cP[1].y = cP[4].y = cP[5].y = p.y +(y*scale);
			cP[2].y = cP[3].y = cP[6].y = cP[7].y =  p.y+((y+1)*scale);
			
			for(int x = -1; x < hg.getWidth();x++){
				//Set x values:
				cP[0].x = cP[3].x = cP[4].x = cP[7].x = p.x+(x*scale);
				cP[1].x = cP[2].x = cP[5].x = cP[6].x = p.x+((x+1)*scale);
				for(int z=-1; z < hg.getDepth();z++){
					//Set z values:
					cP[0].z = cP[1].z = cP[2].z = cP[3].z = p.z+(z*scale);
					cP[4].z = cP[5].z = cP[6].z = cP[7].z = p.z+((z+1)*scale);

					
					//getIsoPoint
//					if(z <  hg.getDepth() && x < hg.getHeight()){
						int cI = getCubeInfo(cP,hg,x,y,z,edges,normals, lm);
						xzCache0[1][x+1][z+1] = getIsoPoint(cI,cP,edges,normals,bb,threshold);
//						cI = getCubeInfo(cP,hg,x,y,z,edges,normals, lm);
//						xzCache0[yOff][x][z+1] = getIsoPoint(cI,cP,edges,normals,bb,threshold);
//					}
					if(z != -1 && x != -1){
//						if(y==2){
//							System.out.println("E");
//						}
//						Vector3f c000,Vector3f c100,Vector3f c010,
//						Vector3f c001,Vector3f c110,Vector3f c101,Vector3f c011
					
						getMaterials(x-1,y-1,z-1,hg,lm);
//						if(lm[5]!= lm[6]){
//							System.out.println("Entry: "+ cP[5].y+" "+cP[6]);
//						}
						
						getTriangles(xzCache0[0][x][z], //cube000
									 xzCache0[0][x+1][z], //cube100
									 xzCache0[1][x][z],	//cube010
									 xzCache0[0][x][z+1], //cube001
									 xzCache0[1][x+1][z], //cube110
									 xzCache0[0][x+1][z+1], //cube101
									 xzCache0[1][x][z+1], //cube 011
									 lm,triangles);
					}
					
				}
			}

			//swap
			Vector3f [][] swap = xzCache0[0];
			xzCache0[0] = xzCache0[1];
			xzCache0[1] = swap;

		}
		
		return triangles;
	}
	
	
	private void setCubeEdges(int x, int y, int z, Vector3f [] cP,float scale,Vector3f v){
		cP[0].y = cP[1].y = cP[4].y = cP[5].y = v.y + (float)y*scale;
		cP[2].y = cP[3].y = cP[6].y = cP[7].y = v.y + (float)(y+1)*scale;
		
		cP[0].x = cP[3].x = cP[4].x = cP[7].x = v.x + (float)x*scale;
		cP[1].x = cP[2].x = cP[5].x = cP[6].x = v.x + (float)(x+1)*scale;
		
		cP[0].z = cP[1].z = cP[2].z = cP[3].z = v.z +(float)z*scale;
		cP[4].z = cP[5].z = cP[6].z = cP[7].z = v.z +(float)(z+1)*scale;
	}
	
	
	private void getMaterials(int x, int y, int z, VoxelGrid hg, int matCache[]){
		matCache[0] = hg.getType(x, y, z);
		matCache[1] = hg.getType(x+1, y, z);
		matCache[2] = hg.getType(x+1, y+1, z);
		matCache[3] = hg.getType(x, y+1, z);
		matCache[4] = hg.getType(x, y, z+1);
		matCache[5] = hg.getType(x+1, y,z+1);
		matCache[6] = hg.getType(x+1, y+1, z+1);
		matCache[7] = hg.getType(x, y+1, z+1);
	}
	
	private int getCubeInfo(Vector3f [] cubeCorners, VoxelGrid hg, int x, int y, int z, List<Vector3f> edges, List<Vector3f> normals,int [] matCache){
		getMaterials(x,y,z,hg,matCache);
		
		int edgeInfo = VoxelSystemTables.getEdgeFromMaterials(matCache);
		edges.clear();
		normals.clear();
		
	
		for (int i = 0; i < 12; i++){ // 12 edges
			if ((edgeInfo & (1 << i)) == 0){
				continue;
			}
			
			// 'i' is the edge #
			// e0, e1 are the cube edges
			int e0 = VoxelSystemTables.iTable[i*2];
			int e1 = VoxelSystemTables.iTable[i*2 +1];
			
			int dx = VoxelSystemTables.cTable[e0*3];
			int dy = VoxelSystemTables.cTable[e0*3 +1];
			int dz = VoxelSystemTables.cTable[e0*3 + 2];
			
			AXIS axis = VoxelSystemTables.aTable[i]; //axis of edge
			
			Float f = hg.getIntersection(x + dx, y + dy, z + dz, axis);
			normals.add(hg.getNormal(x + dx, y + dy, z + dz, axis));
			
			if(f == null){
				System.out.println("Entry "+(x+dx)+","+(y+dy)+","+(z+dz));
			}
			
			edges.add(lerp(cubeCorners[e0],cubeCorners[e1],f));
			
		}
		
		return edgeInfo;
	}
	
	private Vector3f lerp(Vector3f v1, Vector3f v2,float f){
		Vector3f v =  new Vector3f();
		v.x = v1.x + (v2.x - v1.x)*f;
		v.y = v1.y + (v2.y - v1.y)*f;
		v.z = v1.z + (v2.z - v1.z)*f;
		return v;
	}
	
	private Vector3f getIsoPoint(int edgeInfo, Vector3f [] corners, List<Vector3f> edges, List<Vector3f> normals,  BoundingBox bb,float error){ //int[] materials,
		
		if(edgeInfo != 0){
			Vector3f center = corners[0].add(corners[6]).multLocal(.5f);
			bb.setCenter(center);
			
			Vector3f isoPoint = ExtractorUtils.surfaceContour(corners,
								edges.toArray(new Vector3f[edges.size()]),
								normals.toArray(new Vector3f[normals.size()]), 
								bb, error);
			
		
//			int type =  ExtractorUtils.getNearestType(isoPoint, corners, materials);
			
			return isoPoint;//new SurfacePoint(isoPoint, type);
		}
		
		
		return null;
	}
	
	private void getTriangles(Vector3f c000,Vector3f c100,Vector3f c010,Vector3f c001,Vector3f c110,Vector3f c101,Vector3f c011, int [] materials,List<SurfacePoint> trianglesOut){
		int eI = VoxelSystemTables.getEdgeFromMaterials(materials); 
		Vector3f v1= c000,v2,v3,v4;
		//if edge 5
		if((eI & (1<<5)) != 0){
			v2 = c100;
			v3 = c101;
			v4 = c001;
			
			if(v3 == null){
				throw new RuntimeException("ARG");
			}
			
			if(materials[6] == -1){
				QuadExtractor.windingQuadToTriangle(v1,v2,v3,v4,trianglesOut,true, materials[5]);
			}else if(materials[5] == -1){
				QuadExtractor.windingQuadToTriangle(v1,v2,v3,v4,trianglesOut,false, materials[6]);
			}else{
				// Sub-Surface Quad. Check if this is marked for generation
//				QuadExtractor.windingQuadToTriangle(v1,v2,v3,v4, trianglesOut, true,1);
			}
			
		}
		
		//if edge 6
		if((eI & (1<<6)) != 0){
			v2 = c010;
			v3 = c011;
			v4 = c001;
			
			if(materials[7] == -1){
				QuadExtractor.windingQuadToTriangle(v1,v2,v3,v4,trianglesOut,true,materials[6]);
//				QuadExtractor.windingQuadToTriangle(v1,v2,v3,v4, trianglesOut, true,hc.materials[6]);
			}else if(materials[6] == -1){
				QuadExtractor.windingQuadToTriangle(v1,v2,v3,v4,trianglesOut,false,materials[7]);
//				QuadExtractor.windingQuadToTriangle(v1,v2,v3,v4, trianglesOut, false,hc.materials[7]);
			}else{ // Wrapping does not matter for material quads.
				// Sub-Surface Quad. Check if this is marked for generation
//				QuadExtractor.windingQuadToTriangle(v1,v2,v3,v4, trianglesOut, true,1);
			}
		}
		
		//if edge 10
		if((eI & (1<<10)) != 0){
			v2 = c010;
			v3 = c110;
			v4 = c100;
			
			if(materials[6] == -1){
				QuadExtractor.windingQuadToTriangle(v1,v2,v3,v4,trianglesOut,true,materials[2]);
//				QuadExtractor.windingQuadToTriangle(v1,v2,v3,v4, trianglesOut, true,hc.materials[2]);
			}else if(materials[2] == -1){
				QuadExtractor.windingQuadToTriangle(v1,v2,v3,v4,trianglesOut,false,materials[6]);
			}else{ 
				// Sub-Surface Quad. Check if this is marked for generation
//				QuadExtractor.windingQuadToTriangle(v1,v2,v3,v4, trianglesOut, true,1);
			}
		}
		
		
	}



	
}
